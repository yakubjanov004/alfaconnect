# handlers/technician/inbox.py (refactored with i18n uz/ru)
from aiogram import Router, F
from aiogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.fsm.context import FSMContext
from aiogram.exceptions import TelegramBadRequest
from aiogram.filters import StateFilter
from aiogram.fsm.state import State, StatesGroup
from database.basic.user import find_user_by_telegram_id
from loader import bot
import logging
import asyncpg
from config import settings

logger = logging.getLogger(__name__)


async def get_current_status(application_id: int, mode: str = "connection") -> str:
    """Get current status of an application"""
    from database.technician.materials import _conn
    conn = None
    try:
        conn = await _conn()
        if mode == "technician":
            query = """
                SELECT status FROM technician_orders 
                WHERE id = $1
            """
        else:  # connection mode
            query = """
                SELECT status FROM connection_orders 
                WHERE id = $1
            """
        result = await conn.fetchval(query, application_id)
        return result or "noma'lum"
    except Exception as e:
        print(f"Error getting status: {e}")
        return "noma'lum"
    finally:
        if conn:
            await conn.close()

async def get_application_number(application_id: int, mode: str = "connection") -> str:
    """Get application_number from database"""
    from database.technician.materials import _conn
    conn = None
    try:
        conn = await _conn()
        if mode == "technician":
            query = """
                SELECT application_number FROM technician_orders 
                WHERE id = $1
            """
        elif mode == "staff":
            query = """
                SELECT application_number FROM staff_orders 
                WHERE id = $1
            """
        else:  # connection mode
            query = """
                SELECT application_number FROM connection_orders 
                WHERE id = $1
            """
        result = await conn.fetchval(query, application_id)
        return result or str(application_id)
    except Exception as e:
        print(f"Error getting application_number: {e}")
        return str(application_id)
    finally:
        if conn:
            await conn.close()

from datetime import datetime
import html

from filters.role_filter import RoleFilter
from database.basic.user import get_user_by_telegram_id
from keyboards.client_buttons import get_rating_keyboard
from database.technician import (
    # Ulanish (connection_orders) oqimi
    fetch_technician_inbox,
    cancel_technician_request,
    accept_technician_work,
    start_technician_work,
    finish_technician_work,
    fetch_selected_materials_for_request,
    fetch_technician_materials,
    create_material_request_and_mark_in_warehouse,

    # Material oqimi (ikkala rejimda ham ishlatiladi)
    fetch_technician_materials,
    fetch_all_materials,
    fetch_materials_not_assigned_to_technician,
    fetch_material_by_id,
    fetch_assigned_qty,
    upsert_material_selection,
    upsert_material_request_and_decrease_stock,

    # Texnik xizmat (technician_orders) oqimi
    fetch_technician_inbox_tech,
    accept_technician_work_for_tech,
    start_technician_work_for_tech,
    save_technician_diagnosis,
    finish_technician_work_for_tech,
    
    # Xodim arizalari (staff_orders) oqimi
    fetch_technician_inbox_staff,
    accept_technician_work_for_staff,
    start_technician_work_for_staff,
    finish_technician_work_for_staff,
)

# =====================
# I18N
# =====================
T = {
    "title_inbox": {
        "uz": "👨‍🔧 <b>Texnik — Inbox</b>",
        "ru": "👨‍🔧 <b>Техник — Входящие</b>",
    },
    "id": {"uz": "🆔 <b>ID:</b>", "ru": "🆔 <b>ID:</b>"},
    "status": {"uz": "📌 <b>Status:</b>", "ru": "📌 <b>Статус:</b>"},
    "client": {"uz": "👤 <b>Mijoz:</b>", "ru": "👤 <b>Клиент:</b>"},
    "phone": {"uz": "📞 <b>Telefon:</b>", "ru": "📞 <b>Телефон:</b>"},
    "address": {"uz": "📍 <b>Manzil:</b>", "ru": "📍 <b>Адрес:</b>"},
    "tariff": {"uz": "📊 <b>Tarif:</b>", "ru": "📊 <b>Тариф:</b>"},
    "created": {"uz": "📅 <b>Yaratilgan:</b>", "ru": "📅 <b>Создано:</b>"},
    "desc": {"uz": "📝 <b>Tavsif:</b>", "ru": "📝 <b>Описание:</b>"},
    "jm_notes_label": {"uz": "📋 <b>JM izohi:</b>", "ru": "📋 <b>Примечание JM:</b>"},
    "media_yes": {"uz": "📎 <b>Media:</b> bor", "ru": "📎 <b>Медиа:</b> есть"},
    "pager": {"uz": "🗂️ <i>Ariza {i} / {n}</i>", "ru": "🗂️ <i>Заявка {i} / {n}</i>"},
    "staff_creator": {"uz": "👔 <b>Yaratuvchi:</b>", "ru": "👔 <b>Создатель:</b>"},
    "abonent": {"uz": "👤 <b>Abonent:</b>", "ru": "👤 <b>Абонент:</b>"},
    "req_type": {"uz": "📋 <b>Ariza turi:</b>", "ru": "📋 <b>Тип заявки:</b>"},
    "problem": {"uz": "⚠️ <b>Muammo:</b>", "ru": "⚠️ <b>Проблема:</b>"},
    "empty_connection": {"uz": "📭 Ulanish arizalari bo‘sh", "ru": "📭 Заявок на подключение нет"},
    "empty_tech": {"uz": "📭 Texnik xizmat arizalari bo‘sh", "ru": "📭 Заявок на техобслуживание нет"},
    "empty_staff": {"uz": "📭 Xodim arizalari bo‘sh", "ru": "📭 Заявок от сотрудников нет"},
    "choose_section": {"uz": "📂 Qaysi bo‘limni ko‘ramiz?", "ru": "📂 Какой раздел откроем?"},
    "no_perm": {"uz": "❌ Ruxsat yo‘q", "ru": "❌ Нет доступа"},
    "prev": {"uz": "⬅️ Oldingi", "ru": "⬅️ Предыдущая"},
    "next": {"uz": "Keyingi ➡️", "ru": "Следующая ➡️"},
    "cancel": {"uz": "🗑️ Bekor qilish", "ru": "🗑️ Отменить"},
    "accept": {"uz": "✅ Ishni qabul qilish", "ru": "✅ Принять работу"},
    "start": {"uz": "▶️ Ishni boshlash", "ru": "▶️ Начать работу"},
    "diagnostics": {"uz": "🩺 Diagnostika", "ru": "🩺 Диагностика"},
    "finish": {"uz": "✅ Yakunlash", "ru": "✅ Завершить"},
    "warehouse": {"uz": "📦 Ombor", "ru": "📦 Склад"},
    "review": {"uz": "📋 Yakuniy ko‘rinish", "ru": "📋 Итоговый вид"},
    "reached_start": {"uz": "❗️ Boshlanishga yetib keldingiz.", "ru": "❗️ Достигли начала списка."},
    "reached_end": {"uz": "❗️ Oxiriga yetib keldingiz.", "ru": "❗️ Достигли конца списка."},
    "ok_started": {"uz": "✅ Ish boshlandi", "ru": "✅ Работа начата"},
    "ok_cancelled": {"uz": "🗑️ Ariza bekor qilindi", "ru": "🗑️ Заявка отменена"},
    "empty_inbox": {"uz": "📭 Inbox bo‘sh", "ru": "📭 Входящие пусты"},
    "format_err": {"uz": "❌ Xato format", "ru": "❌ Неверный формат"},
    "not_found_mat": {"uz": "❌ Material topilmadi", "ru": "❌ Материал не найден"},
    "enter_qty": {"uz": "📦 <b>Miqdorni kiriting</b>", "ru": "📦 <b>Введите количество</b>"},
    "order_id": {"uz": "🆔 <b>Ariza ID:</b>", "ru": "🆔 <b>ID заявки:</b>"},
    "chosen_prod": {"uz": "📦 <b>Tanlangan mahsulot:</b>", "ru": "📦 <b>Выбранный товар:</b>"},
    "price": {"uz": "💰 <b>Narx:</b>", "ru": "💰 <b>Цена:</b>"},
    "assigned_left": {"uz": "📊 <b>Sizga biriktirilgan qoldiq:</b>", "ru": "📊 <b>Ваш закреплённый остаток:</b>"},
    "enter_qty_hint": {
        "uz": "📝 Iltimos, olinadigan miqdorni kiriting:\n• Faqat raqam (masalan: 2)\n\n<i>Maksimal: {max} dona</i>",
        "ru": "📝 Введите количество:\n• Только число (например: 2)\n\n<i>Максимум: {max} шт</i>",
    },
    "btn_cancel": {"uz": "❌ Bekor qilish", "ru": "❌ Отмена"},
    "only_int": {"uz": "❗️ Faqat butun son kiriting (masalan: 2).", "ru": "❗️ Введите целое число (например: 2)."},
    "gt_zero": {"uz": "❗️ Iltimos, 0 dan katta butun son kiriting.", "ru": "❗️ Введите целое число больше 0."},
    "max_exceeded": {
        "uz": "❗️ Sizga biriktirilgan miqdor: {max} dona. {max} dan oshiq kiritib bo‘lmaydi.",
        "ru": "❗️ Ваш лимит: {max} шт. Нельзя вводить больше {max}.",
    },
    "saved_selection": {"uz": "✅ <b>Tanlov saqlandi</b>", "ru": "✅ <b>Выбор сохранён</b>"},
    "selected_products": {"uz": "📦 <b>Tanlangan mahsulotlar:</b>", "ru": "📦 <b>Выбранные материалы:</b>"},
    "add_more": {"uz": "➕ Yana material tanlash", "ru": "➕ Добавить ещё материал"},
    "final_view": {"uz": "📋 Yakuniy ko‘rinish", "ru": "📋 Итоговый вид"},
    "store_header": {
        "uz": "📦 <b>Ombor jihozlari</b>\n🆔 <b>Ariza ID:</b> {id}\nKerakli jihozlarni tanlang yoki boshqa mahsulot kiriting:",
        "ru": "📦 <b>Складские позиции</b>\n🆔 <b>ID заявки:</b> {id}\nВыберите нужное или введите другой товар:",
    },
    "diag_begin_prompt": {
        "uz": "🩺 <b>Diagnostika matnini kiriting</b>\n\nMasalan: <i>Modem moslamasi ishdan chiqqan</i>.",
        "ru": "🩺 <b>Введите текст диагностики</b>\n\nНапример: <i>Неисправен модем</i>.",
    },
    "diag_saved": {"uz": "✅ <b>Diagnostika qo‘yildi!</b>", "ru": "✅ <b>Диагностика сохранена!</b>"},
    "diag_text": {"uz": "🧰 <b>Diagnostika:</b>", "ru": "🧰 <b>Диагностика:</b>"},
    "go_store_q": {
        "uz": "🧑‍🏭 <b>Ombor bilan ishlaysizmi?</b>\n<i>Agar kerakli jihozlar omborda bo‘lsa, ularni olish kerak.</i>",
        "ru": "🧑‍🏭 <b>Перейти к складу?</b>\n<i>Если нужны материалы — забираем со склада.</i>",
    },
    "yes": {"uz": "✅ Ha", "ru": "✅ Да"},
    "no": {"uz": "❌ Yo‘q", "ru": "❌ Нет"},
    "diag_cancelled": {"uz": "ℹ️ Omborga murojaat qilinmadi. Davom etishingiz mumkin.", "ru": "ℹ️ К складу не обращались. Можно продолжать."},
    "catalog_empty": {"uz": "📦 Katalog bo‘sh.", "ru": "📦 Каталог пуст."},
    "catalog_header": {"uz": "📦 <b>Mahsulot katalogi</b>\nKeraklisini tanlang:", "ru": "📦 <b>Каталог материалов</b>\nВыберите нужное:"},
    "back": {"uz": "⬅️ Orqaga", "ru": "⬅️ Назад"},
    "qty_title": {"uz": "✍️ <b>Miqdorni kiriting</b>", "ru": "✍️ <b>Введите количество</b>"},
    "order": {"uz": "🆔 Ariza:", "ru": "🆔 Заявка:"},
    "product": {"uz": "📦 Mahsulot:", "ru": "📦 Материал:"},
    "price_line": {"uz": "💰 Narx:", "ru": "💰 Цена:"},
    "ctx_lost": {"uz": "❗️ Kontekst yo‘qolgan, qaytadan urinib ko‘ring.", "ru": "❗️ Контекст потерян, попробуйте снова."},
    "req_not_found": {"uz": "❗️ Ariza aniqlanmadi.", "ru": "❗️ Заявка не найдена."},
    "x_error": {"uz": "❌ Xatolik:", "ru": "❌ Ошибка:"},
    "state_cleared": {"uz": "Bekor qilindi", "ru": "Отменено"},
    "status_mismatch": {"uz": "⚠️ Holat mos emas", "ru": "⚠️ Некорректный статус"},
    "status_mismatch_detail": {
        "uz": "⚠️ Holat mos emas (faqat 'in_technician').",
        "ru": "⚠️ Некорректный статус (только 'in_technician').",
    },
    "status_mismatch_finish": {
        "uz": "⚠️ Holat mos emas (faqat 'in_technician_work').",
        "ru": "⚠️ Некорректный статус (только 'in_technician_work').",
    },
    "work_finished": {"uz": "✅ <b>Ish yakunlandi</b>", "ru": "✅ <b>Работа завершена</b>"},
    "used_materials": {"uz": "📦 <b>Ishlatilgan mahsulotlar:</b>", "ru": "📦 <b>Использованные материалы:</b>"},
    "none": {"uz": "• (mahsulot tanlanmadi)", "ru": "• (материалы не выбраны)"},
    "akt_err_ignored": {"uz": "AKT xatoligi ishni to'xtatmaydi", "ru": "Ошибка АКТ не останавливает процесс"},
    "store_request_sent": {
        "uz": "📨 <b>Omborga so‘rov yuborildi</b>",
        "ru": "📨 <b>Заявка на склад отправлена</b>",
    },
    "req_type_info": {
        "uz": "⏳ Ariza holati endi <b>in_warehouse</b>. Omborchi tasdiqlagach yana <b>in_technician_work</b> bo‘ladi.",
        "ru": "⏳ Статус теперь <b>in_warehouse</b>. После подтверждения склада вернётся в <b>in_technician_work</b>.",
    },
    "sections_keyboard": {
        "uz": ["🔌 Ulanish arizalari", "🔧 Texnik xizmat arizalari", "📞 Operator arizalari"],
        "ru": ["🔌 Заявки на подключение", "🔧 Заявки на техобслуживание", "📞 Заявки от операторов"],
    },
}

def t(key: str, lang: str = "uz", **kwargs) -> str:
    val = T.get(key, {}).get(lang, "")
    return val.format(**kwargs) if kwargs else val

async def resolve_lang(user_id: int, fallback: str = "uz") -> str:
    """Foydalanuvchi tilini DB'dan olish: users.lang ('uz'|'ru') bo‘lsa ishlatiladi."""
    try:
        u = await find_user_by_telegram_id(user_id)
        if u:
            lang = (u.get("lang") or u.get("user_lang") or u.get("language") or "").lower()
            if lang in ("uz", "ru"):
                return lang
    except Exception:
        pass
    return fallback

# ====== STATE-lar ======
class QtyStates(StatesGroup):
    waiting_qty = State()
class CustomQtyStates(StatesGroup):
    waiting_qty = State()
class DiagStates(StatesGroup):
    waiting_text = State()

# ====== Router ======
router = Router()
router.message.filter(RoleFilter("technician"))
router.callback_query.filter(RoleFilter("technician"))

# =====================
# Helperlar
# =====================
def _preserve_mode_clear(state: FSMContext, keep_keys: list[str] | None = None):
    async def _inner():
        data = await state.get_data()
        mode = data.get("tech_mode")
        kept: dict = {}
        if keep_keys:
            for k in keep_keys:
                if k in data:
                    kept[k] = data[k]
        await state.clear()
        payload = {"tech_mode": mode}
        payload.update(kept)
        await state.update_data(**payload)
    return _inner()

def fmt_dt(dt) -> str:
    if isinstance(dt, str):
        try:
            dt = datetime.fromisoformat(dt)
        except Exception:
            return html.escape(dt, quote=False)
    if isinstance(dt, datetime):
        return dt.strftime("%d.%m.%Y %H:%M")
    return "-"

def esc(v) -> str:
    return "-" if v is None else html.escape(str(v), quote=False)

def _qty_of(it: dict) -> str:
    q = it.get('qty')
    if q is None:
        q = it.get('quantity', it.get('description'))
    return str(q) if q is not None else "-"

def status_emoji(s: str) -> str:
    m = {
        "between_controller_technician": "🆕",
        "in_technician": "🧰",
        "in_technician_work": "🟢",
        "in_warehouse": "📦",
        "completed": "✅",
    }
    return m.get(s, "📌")

def short_view_text(item: dict, idx: int, total: int, lang: str = "uz", mode: str = "connection") -> str:
    """Build ariza text based on mode"""
    
    # Staff arizalari uchun alohida text
    if mode == "staff":
        base = f"{t('title_inbox', lang)}\n"
        base += f"{t('id', lang)} {esc(item.get('application_number') or item.get('id'))}\n"
        base += f"{status_emoji(item.get('status',''))} {t('status', lang)} {esc(item.get('status'))}\n"
        
        # Ariza turi
        req_type = item.get('type_of_zayavka', '-')
        req_type_uz = "Ulanish" if req_type == "connection" else ("Texnik xizmat" if req_type == "technician" else req_type)
        req_type_ru = "Подключение" if req_type == "connection" else ("Техобслуживание" if req_type == "technician" else req_type)
        base += f"{t('req_type', lang)} {req_type_uz if lang=='uz' else req_type_ru}\n\n"
        
        # Abonent (mijoz) ma'lumotlari
        base += f"{t('abonent', lang)}\n"
        base += f"  • {esc(item.get('client_name'))}\n"
        base += f"  • {esc(item.get('client_phone'))}\n\n"
        
        # Yaratuvchi xodim
        base += f"{t('staff_creator', lang)}\n"
        creator_role = item.get('staff_creator_role', '-')
        base += f"  • {esc(item.get('staff_creator_name'))} ({esc(creator_role)})\n"
        base += f"  • {esc(item.get('staff_creator_phone'))}\n\n"
        
        # Manzil
        base += f"{t('address', lang)} {esc(item.get('address'))}\n"
        
        # Tariff yoki muammo
        tariff_or_problem = item.get('tariff_or_problem')
        if tariff_or_problem:
            if req_type == 'connection':
                base += f"{t('tariff', lang)} {esc(tariff_or_problem)}\n"
            else:
                base += f"{t('problem', lang)} {esc(tariff_or_problem)}\n"
        
        # Tavsif
        desc = (item.get("description") or "").strip()
        if desc:
            short_desc = (desc[:140] + "…") if len(desc) > 140 else desc
            base += f"{t('desc', lang)} {html.escape(short_desc, quote=False)}\n"
        
        # JM notes
        jm_notes = (item.get("jm_notes") or "").strip()
        if jm_notes:
            short_notes = (jm_notes[:100] + "…") if len(jm_notes) > 100 else jm_notes
            base += f"{t('jm_notes_label', lang)} {html.escape(short_notes, quote=False)}\n"
        
        if item.get("created_at"):
            base += f"{t('created', lang)} {fmt_dt(item.get('created_at'))}\n"
        
        base += "\n" + t("pager", lang, i=idx + 1, n=total)
        return base
    
    # Connection va technician arizalari uchun
    base = (
        f"{t('title_inbox', lang)}\n"
        f"{t('id', lang)} {esc(item.get('application_number') or item.get('id'))}\n"
        f"{t('client', lang)} {esc(item.get('client_name'))}\n"
        f"{t('phone', lang)} {esc(item.get('client_phone'))}\n"
        f"{t('address', lang)} {esc(item.get('address'))}\n"
    )
    
    if item.get("tariff"):
        base += f"{t('tariff', lang)} {esc(item.get('tariff'))}\n"
    
    # JM notes (faqat connection uchun)
    if mode == "connection":
        jm_notes = (item.get("jm_notes") or "").strip()
        if jm_notes:
            short_notes = (jm_notes[:100] + "…") if len(jm_notes) > 100 else jm_notes
            base += f"{t('jm_notes_label', lang)} {html.escape(short_notes, quote=False)}\n"
    
    if item.get("created_at"):
        base += f"{t('created', lang)} {fmt_dt(item.get('created_at'))}\n"
    
    desc = (item.get("description") or "").strip()
    if desc:
        short_desc = (desc[:140] + "…") if len(desc) > 140 else desc
        base += f"{t('desc', lang)} {html.escape(short_desc, quote=False)}\n"
    
    base += "\n" + t("pager", lang, i=idx + 1, n=total)
    return base

async def get_selected_materials_summary(user_id: int, req_id: int, lang: str) -> str:
    """Get summary of selected materials for display in inbox"""
    try:
        selected = await fetch_selected_materials_for_request(user_id, req_id)
        if not selected:
            return ""
        
        summary = "\n\n📦 <b>Tanlangan mahsulotlar:</b>\n"
        for mat in selected:
            qty = mat['qty']
            name = mat['name']
            source = "🧑‍🔧 O'zimda" if mat.get('source_type') == 'technician_stock' else "🏢 Ombordan"
            summary += f"• {esc(name)} — {qty} dona [{source}]\n"
        return summary
    except Exception:
        return ""

async def short_view_text_with_materials(item: dict, idx: int, total: int, user_id: int, lang: str = "uz", mode: str = "connection") -> str:
    """Build ariza text with selected materials included"""
    base_text = short_view_text(item, idx, total, lang, mode)
    
    # Add selected materials if any
    req_id = item.get("id")
    if req_id:
        materials_summary = await get_selected_materials_summary(user_id, req_id, lang)
        if materials_summary:
            # Insert materials before pager
            pager_start = base_text.rfind(t("pager", lang, i=idx + 1, n=total))
            if pager_start != -1:
                base_text = base_text[:pager_start] + materials_summary + "\n" + base_text[pager_start:]
            else:
                base_text += materials_summary
    
    return base_text

def _short(s: str, n: int = 48) -> str:
    s = str(s)
    return s if len(s) <= n else s[: n - 1] + "…"

def _fmt_price_uzs(val) -> str:
    try:
        s = f"{int(val):,}"
        return s.replace(",", " ")
    except Exception:
        return str(val)

async def send_completion_notification_to_client(bot, request_id: int, request_type: str):
    """
    Texnik ishni yakunlagandan so'ng clientga ariza haqida to'liq ma'lumot yuborish va rating so'rash.
    AKT yuborilmaydi - faqat ma'lumot va rating tizimi.
    """
    try:
        # Client ma'lumotlarini olish
        client_data = await get_client_data_for_notification(request_id, request_type)
        if not client_data or not client_data.get('client_telegram_id'):
            logger.warning(f"No client data found for {request_type} request {request_id}")
            return

        client_telegram_id = client_data['client_telegram_id']
        client_lang = client_data.get('client_lang', 'uz')
        
        # Ariza turini til bo'yicha formatlash
        if client_lang == "ru":
            if request_type == "connection":
                order_type_text = "подключения"
            elif request_type == "technician":
                order_type_text = "технической"
            else:
                order_type_text = "сотрудника"
        else:
            if request_type == "connection":
                order_type_text = "ulanish"
            elif request_type == "technician":
                order_type_text = "texnik xizmat"
            else:
                order_type_text = "xodim"

        # Ishlatilgan materiallarni olish
        materials_info = await get_used_materials_info(request_id, request_type, client_lang)
        
        # Diagnostika ma'lumotini olish (texnik xizmat uchun)
        diagnosis_info = await get_diagnosis_info(request_id, request_type, client_lang)

        # Notification matnini tayyorlash
        if client_lang == "ru":
            message = (
                "✅ <b>Работа завершена!</b>\n\n"
                f"📋 Заявка {order_type_text}: #{request_id}\n"
                f"📅 Дата завершения: {datetime.now().strftime('%d.%m.%Y %H:%M')}\n\n"
            )
            
            if diagnosis_info:
                message += f"🔧 <b>Выполненные работы:</b>\n{diagnosis_info}\n\n"
            
            if materials_info:
                message += f"📦 <b>Использованные материалы:</b>\n{materials_info}\n\n"
            
            message += "<i>Пожалуйста, оцените качество нашей работы:</i>"
        else:
            message = (
                "✅ <b>Ish yakunlandi!</b>\n\n"
                f"📋 {order_type_text} arizasi: #{request_id}\n"
                f"📅 Yakunlangan sana: {datetime.now().strftime('%d.%m.%Y %H:%M')}\n\n"
            )
            
            if diagnosis_info:
                message += f"🔧 <b>Bajarilgan ishlar:</b>\n{diagnosis_info}\n\n"
            
            if materials_info:
                message += f"📦 <b>Ishlatilgan materiallar:</b>\n{materials_info}\n\n"
            
            message += "<i>Iltimos, xizmatimizni baholang:</i>"

        # Rating keyboard yaratish
        rating_keyboard = get_rating_keyboard(request_id, request_type)
        
        # Xabarni yuborish
        await bot.send_message(
            chat_id=client_telegram_id,
            text=message,
            parse_mode='HTML',
            reply_markup=rating_keyboard
        )
        
        logger.info(f"Completion notification sent to client {client_telegram_id} for {request_type} request {request_id}")
        
    except Exception as e:
        logger.error(f"Error sending completion notification to client: {e}")
        raise

async def get_client_data_for_notification(request_id: int, request_type: str):
    """
    Client ma'lumotlarini olish notification uchun.
    """
    from database.connections import get_connection_url
    import asyncpg
    
    try:
        conn = await asyncpg.connect(get_connection_url())
        try:
            if request_type == "connection":
                query = """
                    SELECT 
                        co.client_telegram_id,
                        u.lang as client_lang,
                        co.client_name,
                        co.client_phone,
                        co.address
                    FROM connection_orders co
                    LEFT JOIN users u ON u.telegram_id = co.client_telegram_id
                    WHERE co.id = $1
                """
            elif request_type == "technician":
                query = """
                    SELECT 
                        to.client_telegram_id,
                        u.lang as client_lang,
                        to.client_name,
                        to.client_phone,
                        to.address
                    FROM technician_orders to
                    LEFT JOIN users u ON u.telegram_id = to.client_telegram_id
                    WHERE to.id = $1
                """
            elif request_type == "staff":
                query = """
                    SELECT 
                        so.client_telegram_id,
                        u.lang as client_lang,
                        so.client_name,
                        so.client_phone,
                        so.address
                    FROM staff_orders so
                    LEFT JOIN users u ON u.telegram_id = so.client_telegram_id
                    WHERE so.id = $1
                """
            else:
                return None
                
            result = await conn.fetchrow(query, request_id)
            return dict(result) if result else None
            
        finally:
            await conn.close()
    except Exception as e:
        logger.error(f"Error getting client data: {e}")
        return None

async def get_used_materials_info(request_id: int, request_type: str, client_lang: str = "uz"):
    """
    Ishlatilgan materiallar haqida ma'lumot olish.
    """
    try:
        from database.connections import get_connection_url
        import asyncpg
        
        conn = await asyncpg.connect(get_connection_url())
        try:
            if request_type == "connection":
                query = """
                    SELECT 
                        m.name as material_name,
                        mr.quantity,
                        mr.price
                    FROM material_requests mr
                    JOIN materials m ON m.id = mr.material_id
                    WHERE mr.applications_id = $1
                    ORDER BY mr.created_at
                """
            elif request_type == "technician":
                query = """
                    SELECT 
                        m.name as material_name,
                        mr.quantity,
                        mr.price
                    FROM material_requests mr
                    JOIN materials m ON m.id = mr.material_id
                    WHERE mr.applications_id = $1
                    ORDER BY mr.created_at
                """
            elif request_type == "staff":
                query = """
                    SELECT 
                        m.name as material_name,
                        mr.quantity,
                        mr.price
                    FROM material_requests mr
                    JOIN materials m ON m.id = mr.material_id
                    WHERE mr.applications_id = $1
                    ORDER BY mr.created_at
                """
            else:
                return ""
                
            materials = await conn.fetch(query, request_id)
            
            if not materials:
                return "• Hech qanday material ishlatilmagan" if client_lang == "uz" else "• Материалы не использовались"
            
            materials_text = []
            for mat in materials:
                name = mat['material_name'] or "Noma'lum"
                qty = mat['quantity'] or 0
                price = mat['price'] or 0
                total_price = qty * price
                
                if client_lang == "ru":
                    materials_text.append(f"• {name} — {qty} шт. (💰 {_fmt_price_uzs(total_price)} сум)")
                else:
                    materials_text.append(f"• {name} — {qty} dona (💰 {_fmt_price_uzs(total_price)} so'm)")
            
            return "\n".join(materials_text)
            
        finally:
            await conn.close()
    except Exception as e:
        logger.error(f"Error getting materials info: {e}")
        return ""

async def get_diagnosis_info(request_id: int, request_type: str, client_lang: str = "uz"):
    """
    Diagnostika ma'lumotini olish (faqat texnik xizmat uchun).
    """
    try:
        if request_type != "technician":
            return ""
            
        from database.connections import get_connection_url
        import asyncpg
        
        conn = await asyncpg.connect(get_connection_url())
        try:
            query = """
                SELECT description
                FROM technician_orders
                WHERE id = $1 AND description IS NOT NULL
            """
            
            result = await conn.fetchval(query, request_id)
            
            if not result:
                return ""
            
            # Diagnostika matnini qisqartirish
            diagnosis = result.strip()
            if len(diagnosis) > 200:
                diagnosis = diagnosis[:200] + "..."
            
            return diagnosis
            
        finally:
            await conn.close()
    except Exception as e:
        logger.error(f"Error getting diagnosis info: {e}")
        return ""

def materials_keyboard(materials: list[dict], applications_id: int, lang: str = "uz") -> InlineKeyboardMarkup:
    rows = []
    if materials:
        for mat in materials:
            name = _short(mat.get('name', 'NO NAME'))
            price = _fmt_price_uzs(mat.get('price', 0))
            stock = mat.get('stock_quantity', '0')
            title = f"📦 {name} — {price} so'm ({stock} dona)" if lang == "uz" else f"📦 {name} — {price} сум ({stock} шт)"
            rows.append([InlineKeyboardButton(
                text=title[:64],
                callback_data=f"tech_mat_select_{mat.get('material_id')}_{applications_id}"
            )])
    rows.append([InlineKeyboardButton(text=("➕ Boshqa mahsulot" if lang == "uz" else "➕ Другой материал"),
                                      callback_data=f"tech_mat_custom_{applications_id}")])
    return InlineKeyboardMarkup(inline_keyboard=rows)

def unassigned_materials_keyboard(materials: list[dict], applications_id: int, lang: str = "uz") -> InlineKeyboardMarkup:
    """Texnikka biriktirilmagan materiallar uchun keyboard"""
    rows = []
    if materials:
        for mat in materials:
            name = _short(mat.get('name', 'NO NAME'))
            price = _fmt_price_uzs(mat.get('price', 0))
            stock = mat.get('stock_quantity', '0')
            title = f"📦 {name} — {price} so'm ({stock} dona)" if lang == "uz" else f"📦 {name} — {price} сум ({stock} шт)"
            rows.append([InlineKeyboardButton(
                text=title[:64],
                callback_data=f"tech_unassigned_select_{mat.get('material_id')}_{applications_id}"
            )])
    rows.append([InlineKeyboardButton(text=("⬅️ Orqaga" if lang == "uz" else "⬅️ Назад"),
                                      callback_data=f"tech_back_to_materials_{applications_id}")])
    return InlineKeyboardMarkup(inline_keyboard=rows)

def action_keyboard(item_id: int, index: int, total: int, status: str, mode: str = "connection", lang: str = "uz") -> InlineKeyboardMarkup:
    rows: list[list[InlineKeyboardButton]] = []
    if total > 1:
        nav = []
        if index > 0:
            nav.append(InlineKeyboardButton(text=t("prev", lang), callback_data=f"tech_inbox_prev_{index}"))
        if index < total - 1:
            nav.append(InlineKeyboardButton(text=t("next", lang), callback_data=f"tech_inbox_next_{index}"))
        if nav:
            rows.append(nav)
    if status == "between_controller_technician":
        rows.append([
            InlineKeyboardButton(text=t("cancel", lang), callback_data=f"tech_cancel_{item_id}"),
            InlineKeyboardButton(text=t("accept", lang), callback_data=f"tech_accept_{item_id}"),
        ])
    elif status == "in_technician":
        rows.append([InlineKeyboardButton(text=t("start", lang), callback_data=f"tech_start_{item_id}")])
    elif status == "in_technician_work":
        if mode == "technician":
            rows.append([InlineKeyboardButton(text=t("diagnostics", lang), callback_data=f"tech_diag_begin_{item_id}")])
            rows.append([InlineKeyboardButton(text=t("finish", lang), callback_data=f"tech_finish_{item_id}")])
        else:
            rows.append([
                InlineKeyboardButton(text=t("warehouse", lang), callback_data=f"tech_add_more_{item_id}"),
                InlineKeyboardButton(text=t("review", lang), callback_data=f"tech_review_{item_id}"),
            ])
    return InlineKeyboardMarkup(inline_keyboard=rows)

def _dedup_by_id(items: list[dict]) -> list[dict]:
    seen = set(); out = []
    for it in items:
        i = it.get("id")
        if i in seen: continue
        seen.add(i); out.append(it)
    return out

def tech_category_keyboard(lang: str = "uz") -> InlineKeyboardMarkup:
    a, b, c = T["sections_keyboard"][lang]
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=a, callback_data="tech_inbox_cat_connection")],
        [InlineKeyboardButton(text=b, callback_data="tech_inbox_cat_tech")],
        [InlineKeyboardButton(text=c, callback_data="tech_inbox_cat_operator")],
    ])

async def _safe_edit(message, text: str, kb: InlineKeyboardMarkup):
    try:
        if message.text == text:
            try:
                await message.edit_reply_markup(reply_markup=kb)
                return
            except TelegramBadRequest as e:
                if "message is not modified" in str(e):
                    return
                raise
        await message.edit_text(text, reply_markup=kb, parse_mode="HTML")
    except TelegramBadRequest as e:
        if "message is not modified" in str(e):
            return
        raise

async def render_item(message, item: dict, idx: int, total: int, lang: str, mode: str, user_id: int = None):
    """Arizani rasm bilan yoki rasmsiz ko'rsatish"""
    if user_id:
        text = await short_view_text_with_materials(item, idx, total, user_id, lang, mode)
    else:
        text = short_view_text(item, idx, total, lang, mode)
    kb = action_keyboard(item.get("id"), idx, total, item.get("status", ""), mode=mode, lang=lang)
    
    media_file_id = item.get("media_file_id")
    media_type = item.get("media_type")
    
    try:
        # Eski xabarni o'chirish (inline tugmalar qolmasligi uchun)
        try:
            await message.delete()
        except:
            pass
        
        # Yangi xabar yuborish
        if media_file_id and media_type:
            try:
                if media_type == 'photo':
                    await bot.send_photo(
                        chat_id=message.chat.id,
                        photo=media_file_id,
                        caption=text,
                        parse_mode='HTML',
                        reply_markup=kb
                    )
                elif media_type == 'video':
                    await bot.send_video(
                        chat_id=message.chat.id,
                        video=media_file_id,
                        caption=text,
                        parse_mode='HTML',
                        reply_markup=kb
                    )
                else:
                    await bot.send_message(message.chat.id, text, parse_mode='HTML', reply_markup=kb)
            except Exception:
                # Agar media yuborishda xatolik bo'lsa, faqat matn yuboramiz
                await bot.send_message(message.chat.id, text, parse_mode='HTML', reply_markup=kb)
        else:
            await bot.send_message(message.chat.id, text, parse_mode='HTML', reply_markup=kb)
    except Exception:
        # Agar delete ishlamasa ham, matn yuborishga harakat qilamiz
        try:
            await bot.send_message(message.chat.id, text, parse_mode='HTML', reply_markup=kb)
        except:
            pass

# ====== Inbox ochish: avval kategoriya ======
@router.message(F.text.in_(["📥 Inbox", "Inbox", "📥 Входящие"]))
async def tech_open_inbox(message: Message, state: FSMContext):
    user = await find_user_by_telegram_id(message.from_user.id)
    if not user or user.get("role") != "technician":
        return
    lang = await resolve_lang(message.from_user.id, fallback=("ru" if message.text == "📥 Входящие" else "uz"))
    await state.update_data(tech_mode=None, tech_inbox=[], tech_idx=0, lang=lang)
    await message.answer(t("choose_section", lang), reply_markup=tech_category_keyboard(lang))

# ====== Kategoriya handlerlari ======
@router.callback_query(F.data == "tech_inbox_cat_connection")
async def tech_cat_connection(cb: CallbackQuery, state: FSMContext):
    await cb.answer()
    st = await state.get_data(); lang = st.get("lang") or await resolve_lang(cb.from_user.id)
    user = await find_user_by_telegram_id(cb.from_user.id)
    if not user or user.get("role") != "technician":
        return await cb.answer(t("no_perm", lang), show_alert=True)

    items = _dedup_by_id(await fetch_technician_inbox(technician_id=user["id"], limit=50, offset=0))
    await state.update_data(tech_mode="connection", tech_inbox=items, tech_idx=0, lang=lang)
    if not items:
        return await cb.message.edit_text(t("empty_connection", lang), reply_markup=InlineKeyboardMarkup(inline_keyboard=[]))
    
    # Connection arizalarida rasmlar bo'lmaydi, shuning uchun oddiy edit
    item = items[0]; total = len(items)
    text = await short_view_text_with_materials(item, 0, total, user["id"], lang, mode="connection")
    kb = action_keyboard(item.get("id"), 0, total, item.get("status", ""), mode="connection", lang=lang)
    await cb.message.edit_text(text, reply_markup=kb, parse_mode="HTML")

@router.callback_query(F.data == "tech_inbox_cat_tech")
async def tech_cat_tech(cb: CallbackQuery, state: FSMContext):
    await cb.answer()
    st = await state.get_data(); lang = st.get("lang") or await resolve_lang(cb.from_user.id)
    user = await find_user_by_telegram_id(cb.from_user.id)
    if not user or user.get("role") != "technician":
        return await cb.answer(t("no_perm", lang), show_alert=True)

    items = _dedup_by_id(await fetch_technician_inbox_tech(technician_id=user["id"], limit=50, offset=0))
    await state.update_data(tech_mode="technician", tech_inbox=items, tech_idx=0, lang=lang)
    if not items:
        return await cb.message.edit_text(t("empty_tech", lang), reply_markup=InlineKeyboardMarkup(inline_keyboard=[]))
    
    # Texnik xizmat arizalarida rasmlar bo'lishi mumkin - render_item ishlatamiz
    await render_item(cb.message, items[0], 0, len(items), lang, "technician", user["id"])

@router.callback_query(F.data == "tech_inbox_cat_operator")
async def tech_cat_operator(cb: CallbackQuery, state: FSMContext):
    await cb.answer()
    st = await state.get_data(); lang = st.get("lang") or await resolve_lang(cb.from_user.id)
    user = await find_user_by_telegram_id(cb.from_user.id)
    if not user or user.get("role") != "technician":
        return await cb.answer(t("no_perm", lang), show_alert=True)

    items = _dedup_by_id(await fetch_technician_inbox_staff(technician_id=user["id"], limit=50, offset=0))
    await state.update_data(tech_mode="staff", tech_inbox=items, tech_idx=0, lang=lang)
    if not items:
        return await cb.message.edit_text(t("empty_staff", lang), reply_markup=InlineKeyboardMarkup(inline_keyboard=[]))
    
    # Staff arizalarida rasmlar yo'q - oddiy edit
    item = items[0]; total = len(items)
    text = await short_view_text_with_materials(item, 0, total, user["id"], lang, mode="staff")
    kb = action_keyboard(item.get("id"), 0, total, item.get("status", ""), mode="staff", lang=lang)
    await cb.message.edit_text(text, reply_markup=kb, parse_mode="HTML")

# ====== Navigatsiya (prev/next) ======
@router.callback_query(F.data.startswith("tech_inbox_prev_"))
async def tech_prev(cb: CallbackQuery, state: FSMContext):
    await cb.answer()
    st = await state.get_data(); lang = st.get("lang") or await resolve_lang(cb.from_user.id)
    user = await find_user_by_telegram_id(cb.from_user.id)
    if not user or user.get("role") != "technician":
        return await cb.answer(t("no_perm", lang), show_alert=True)
    
    mode = st.get("tech_mode", "connection")
    items = _dedup_by_id(st.get("tech_inbox", []))
    if not items:
        return await cb.answer(t("empty_inbox", lang))
    total = len(items)
    idx = int(cb.data.replace("tech_inbox_prev_", "")) - 1
    if idx < 0 or idx >= total:
        return await cb.answer(t("reached_start", lang))
    await state.update_data(tech_inbox=items, tech_idx=idx)
    
    # Modga qarab render qilish
    if mode == "technician":
        # Technician mode - rasmlar bor, render_item
        await render_item(cb.message, items[idx], idx, total, lang, mode, user["id"])
    else:
        # Connection/staff mode - rasmlar yo'q, oddiy edit
        text = await short_view_text_with_materials(items[idx], idx, total, user["id"], lang, mode)
        kb = action_keyboard(items[idx].get("id"), idx, total, items[idx].get("status", ""), mode=mode, lang=lang)
        await _safe_edit(cb.message, text, kb)

@router.callback_query(F.data.startswith("tech_inbox_next_"))
async def tech_next(cb: CallbackQuery, state: FSMContext):
    await cb.answer()
    st = await state.get_data(); lang = st.get("lang") or await resolve_lang(cb.from_user.id)
    user = await find_user_by_telegram_id(cb.from_user.id)
    if not user or user.get("role") != "technician":
        return await cb.answer(t("no_perm", lang), show_alert=True)
    
    mode = st.get("tech_mode", "connection")
    items = _dedup_by_id(st.get("tech_inbox", []))
    if not items:
        return await cb.answer(t("empty_inbox", lang))
    total = len(items)
    idx = int(cb.data.replace("tech_inbox_next_", "")) + 1
    if idx < 0 or idx >= total:
        return await cb.answer(t("reached_end", lang))
    await state.update_data(tech_inbox=items, tech_idx=idx)
    
    # Modga qarab render qilish
    if mode == "technician":
        # Technician mode - rasmlar bor, render_item
        await render_item(cb.message, items[idx], idx, total, lang, mode, user["id"])
    else:
        # Connection/staff mode - rasmlar yo'q, oddiy edit
        text = await short_view_text_with_materials(items[idx], idx, total, user["id"], lang, mode)
        kb = action_keyboard(items[idx].get("id"), idx, total, items[idx].get("status", ""), mode=mode, lang=lang)
        await _safe_edit(cb.message, text, kb)

# ====== Qabul qilish / Bekor qilish / Boshlash ======
@router.callback_query(F.data.startswith("tech_accept_"))
async def tech_accept(cb: CallbackQuery, state: FSMContext):
    st = await state.get_data(); lang = st.get("lang") or await resolve_lang(cb.from_user.id)
    mode = st.get("tech_mode", "connection")
    user = await find_user_by_telegram_id(cb.from_user.id)
    if not user or user.get("role") != "technician":
        return await cb.answer(t("no_perm", lang), show_alert=True)

    req_id = int(cb.data.replace("tech_accept_", ""))
    try:
        if mode == "technician":
            ok = await accept_technician_work_for_tech(applications_id=req_id, technician_id=user["id"])
        elif mode == "staff":
            ok = await accept_technician_work_for_staff(applications_id=req_id, technician_id=user["id"])
        else:
            ok = await accept_technician_work(applications_id=req_id, technician_id=user["id"])
        if not ok:
            return await cb.answer(t("status_mismatch", lang), show_alert=True)
        
        # Controller'ga notification yuboramiz (texnik qabul qildi)
        try:
            from utils.notification_service import send_role_notification
            from database.basic.user import get_user_by_telegram_id
            
            # Controller'ning telegram_id ni olamiz
            controller_user = await get_user_by_telegram_id(cb.from_user.id)  # Technician ID
            if controller_user and controller_user.get('telegram_id'):
                # Notification yuborish
                await send_role_notification(
                    bot=bot,
                    recipient_telegram_id=controller_user['telegram_id'],
                    order_id=f"#{req_id}",
                    order_type=mode if mode != "connection" else "connection",
                    current_load=1,  # Controller'ning hozirgi yuklamasi
                    lang=controller_user.get('language', 'uz')
                )
                logger.info(f"Notification sent to controller - technician accepted order {req_id}")
        except Exception as notif_error:
            logger.error(f"Failed to send notification to controller: {notif_error}")
            # Notification xatosi asosiy jarayonga ta'sir qilmaydi
    except Exception as e:
        return await cb.answer(f"{t('x_error', lang)} {e}", show_alert=True)

    items = _dedup_by_id((await state.get_data()).get("tech_inbox", []))
    idx = int((await state.get_data()).get("tech_idx", 0))
    for it in items:
        if it.get("id") == req_id:
            it["status"] = "in_technician"
            break
    await state.update_data(tech_inbox=items)
    total = len(items)
    item = items[idx] if 0 <= idx < total else items[0]
    
    # Modga qarab render qilish
    if mode == "technician":
        await render_item(cb.message, item, idx, total, lang, mode, user["id"])
    else:
        # Connection/staff mode - oddiy edit
        text = await short_view_text_with_materials(item, idx, total, user["id"], lang, mode)
        kb = action_keyboard(item.get("id"), idx, total, item.get("status", ""), mode=mode, lang=lang)
        await _safe_edit(cb.message, text, kb)
    
    await cb.answer()

@router.callback_query(F.data.startswith("tech_cancel_"))
async def tech_cancel(cb: CallbackQuery, state: FSMContext):
    st = await state.get_data(); lang = st.get("lang") or await resolve_lang(cb.from_user.id)
    mode = st.get("tech_mode", "connection")
    if mode != "connection":
        return await cb.answer(t("no_perm", lang), show_alert=True)

    user = await find_user_by_telegram_id(cb.from_user.id)
    if not user or user.get("role") != "technician":
        return await cb.answer(t("no_perm", lang), show_alert=True)

    req_id = int(cb.data.replace("tech_cancel_", ""))
    try:
        await cancel_technician_request(applications_id=req_id, technician_id=user["id"])
    except Exception as e:
        return await cb.answer(f"{t('x_error', lang)} {e}", show_alert=True)

    items = _dedup_by_id(st.get("tech_inbox", []))
    idx = int(st.get("tech_idx", 0))
    items = [it for it in items if it.get("id") != req_id]

    if not items:
        await state.update_data(tech_inbox=[], tech_idx=0)
        await cb.answer(t("ok_cancelled", lang))
        return await _safe_edit(cb.message, t("empty_inbox", lang), InlineKeyboardMarkup(inline_keyboard=[]))

    if idx >= len(items):
        idx = len(items) - 1

    await state.update_data(tech_inbox=items, tech_idx=idx)
    total = len(items); item = items[idx]
    
    # Modga qarab render qilish
    if mode == "technician":
        await render_item(cb.message, item, idx, total, lang, mode, user["id"])
    else:
        # Connection/staff mode - oddiy edit
        text = await short_view_text_with_materials(item, idx, total, user["id"], lang, mode)
        kb = action_keyboard(item.get("id"), idx, total, item.get("status", ""), mode=mode, lang=lang)
        await _safe_edit(cb.message, text, kb)

@router.callback_query(F.data.startswith("tech_start_"))
async def tech_start(cb: CallbackQuery, state: FSMContext):
    st = await state.get_data(); lang = st.get("lang") or await resolve_lang(cb.from_user.id)
    mode = st.get("tech_mode", "connection")
    user = await find_user_by_telegram_id(cb.from_user.id)
    if not user or user.get("role") != "technician":
        return await cb.answer(t("no_perm", lang), show_alert=True)
    req_id = int(cb.data.replace("tech_start_", ""))
    try:
        if mode == "technician":
            ok = await start_technician_work_for_tech(applications_id=req_id, technician_id=user["id"])
        elif mode == "staff":
            ok = await start_technician_work_for_staff(applications_id=req_id, technician_id=user["id"])
        else:
            ok = await start_technician_work(applications_id=req_id, technician_id=user["id"])
        if not ok:
            current_status = await get_current_status(req_id, mode)
            error_msg = f"⚠️ Xatolik! Avval 'Qabul qilish' tugmasini bosing.\n\n"
            error_msg += f"Joriy holat: {current_status or 'noma\'lum'}\n"
            error_msg += "Kerakli holat: in_technician"
            return await cb.answer(error_msg, show_alert=True)
    except Exception as e:
        return await cb.answer(f"{t('x_error', lang)} {e}", show_alert=True)

    items = _dedup_by_id((await state.get_data()).get("tech_inbox", []))
    idx = int((await state.get_data()).get("tech_idx", 0))
    for it in items:
        if it.get("id") == req_id:
            it["status"] = "in_technician_work"
            break
    await state.update_data(tech_inbox=items)

    total = len(items)
    item = items[idx] if 0 <= idx < total else items[0]
    
    # Modga qarab render qilish
    if mode == "technician":
        await render_item(cb.message, item, idx, total, lang, mode, user["id"])
        # Technician mode uchun alohida diagnostics xabari
        diag_kb = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text=t("diagnostics", lang), callback_data=f"tech_diag_begin_{req_id}")]
        ])
        await cb.message.answer(
            t("ok_started", lang) + "\n\n" + t("diag_begin_prompt", lang),
            reply_markup=diag_kb
        )
    elif mode == "staff":
        await render_item(cb.message, item, idx, total, lang, mode, user["id"])
        
        # Staff arizaning type_of_zayavka ni tekshirish
        conn = await asyncpg.connect(settings.DB_URL)
        try:
            staff_type = await conn.fetchval(
                "SELECT type_of_zayavka FROM staff_orders WHERE id = $1",
                req_id
            )
        finally:
            await conn.close()
        
        if staff_type == "technician":
            # Texnik ariza - diagnostika kerak
            diag_kb = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text=t("diagnostics", lang), callback_data=f"tech_diag_begin_{req_id}")]
            ])
            await cb.message.answer(
                t("ok_started", lang) + "\n\n" + t("diag_begin_prompt", lang),
                reply_markup=diag_kb
            )
        else:
            # Ulanish arizasi - diagnostika yo'q, to'g'ridan-to'g'ri materiallar
            await cb.answer(t("ok_started", lang))
            return
    else:
        # Connection mode - faqat mavjud xabarni yangilaydi, yangi xabar yubormaydi
        text = await short_view_text_with_materials(item, idx, total, user["id"], lang, mode)
        kb = action_keyboard(item.get("id"), idx, total, item.get("status", ""), mode=mode, lang=lang)
        await _safe_edit(cb.message, text, kb)
        await cb.answer(t("ok_started", lang))
        return

    # Application number ni olish (faqat technician mode uchun)
    app_number = await get_application_number(req_id, mode)
    
    mats = await fetch_technician_materials()
    header_text = t("store_header", lang, id=app_number)
    await cb.message.answer(header_text, reply_markup=materials_keyboard(mats, applications_id=req_id, lang=lang), parse_mode="HTML")

# ====== DIAGNOSTIKA ======
@router.callback_query(F.data.startswith("tech_diag_begin_"))
async def tech_diag_begin(cb: CallbackQuery, state: FSMContext):
    await cb.answer()
    st = await state.get_data(); lang = st.get("lang") or await resolve_lang(cb.from_user.id)
    try:
        req_id = int(cb.data.replace("tech_diag_begin_", ""))
    except Exception:
        return
    await state.update_data(diag_req_id=req_id, lang=lang)
    
    # Avvalgi xabardagi inline keyboard'ni tozalash
    try:
        await cb.message.edit_reply_markup(reply_markup=None)
    except Exception:
        pass  # Agar edit qila olmasa, davom etamiz
    
    await cb.message.answer(t("diag_begin_prompt", lang), parse_mode="HTML")
    await state.set_state(DiagStates.waiting_text)

@router.message(StateFilter(DiagStates.waiting_text))
async def tech_diag_text(msg: Message, state: FSMContext):
    user = await find_user_by_telegram_id(msg.from_user.id)
    st = await state.get_data(); lang = st.get("lang") or await resolve_lang(msg.from_user.id)
    if not user or user.get("role") != "technician":
        return await msg.answer(t("no_perm", lang))

    data = await state.get_data()
    req_id = int(data.get("diag_req_id", 0))
    if req_id <= 0:
        await _preserve_mode_clear(state)
        return await msg.answer(t("req_not_found", lang))

    text = (msg.text or "").strip()
    if not text:
        return await msg.answer(t("only_int", lang))  # qisqa validatsiya xabari sifatida qayta ishlatildi

    try:
        # Mode'ga qarab to'g'ri jadvalga diagnostika yozish
        mode = st.get("tech_mode", "connection")
        if mode == "staff":
            # Staff arizalar uchun staff_orders jadvaliga yozish
            conn = await asyncpg.connect(settings.DB_URL)
            try:
                # Faqat technician type uchun diagnostika yozish
                await conn.execute(
                    """
                    UPDATE staff_orders
                       SET diagnostics = $2,
                           updated_at = NOW()
                     WHERE id = $1 AND type_of_zayavka = 'technician'
                    """,
                    req_id, text
                )
            finally:
                await conn.close()
        else:
            # Technician arizalar uchun technician_orders jadvaliga yozish
            await save_technician_diagnosis(applications_id=req_id, technician_id=user["id"], text=text)
    except Exception as e:
        await _preserve_mode_clear(state)
        return await msg.answer(f"{t('x_error', lang)} {e}")

    # Mode ni olish
    mode = st.get("tech_mode", "connection")
    
    await _preserve_mode_clear(state)

    # Diagnostika xabarini o'chirish
    try:
        await msg.delete()
    except Exception:
        pass  # Agar o'chirishda xatolik bo'lsa, davom etamiz

    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=t("yes", lang),  callback_data=f"tech_diag_go_store_{req_id}")],
        [InlineKeyboardButton(text=t("no", lang), callback_data=f"tech_diag_cancel_{req_id}")],
    ])
    # Application number ni olish
    app_number = await get_application_number(req_id, mode)
    
    await msg.answer(
        f"{t('diag_saved', lang)}\n\n"
        f"{t('order_id', lang)} {esc(app_number)}\n"
        f"{t('diag_text', lang)}\n<code>{html.escape(text, quote=False)}</code>\n\n"
        f"{t('go_store_q', lang)}",
        reply_markup=kb,
        parse_mode="HTML"
    )

@router.callback_query(F.data.startswith("tech_diag_go_store_"))
async def tech_diag_go_store(cb: CallbackQuery, state: FSMContext):
    await cb.answer()
    st = await state.get_data(); lang = st.get("lang") or await resolve_lang(cb.from_user.id)
    try:
        req_id = int(cb.data.replace("tech_diag_go_store_", ""))
    except Exception:
        return
    user = await find_user_by_telegram_id(cb.from_user.id)
    if not user or user.get("role") != "technician":
        return await cb.answer(t("no_perm", lang), show_alert=True)

    # Inline keyboard'ni tozalash
    try:
        await cb.message.edit_reply_markup(reply_markup=None)
    except Exception:
        pass  # Agar tozalashda xatolik bo'lsa, davom etamiz

    # Application number ni olish
    mode = st.get("tech_mode", "connection")
    app_number = await get_application_number(req_id, mode)
    
    mats = await fetch_technician_materials()
    header_text = t("store_header", lang, id=app_number)
    await cb.message.answer(header_text, reply_markup=materials_keyboard(mats, applications_id=req_id, lang=lang), parse_mode="HTML")

@router.callback_query(F.data.startswith("tech_diag_cancel_"))
async def tech_diag_cancel(cb: CallbackQuery, state: FSMContext):
    st = await state.get_data(); lang = st.get("lang") or await resolve_lang(cb.from_user.id)
    await cb.answer(t("state_cleared", lang))
    
    try:
        req_id = int(cb.data.replace("tech_diag_cancel_", ""))
    except Exception:
        await _preserve_mode_clear(state)
        await cb.message.answer(t("diag_cancelled", lang))
        return
    
    # Inline keyboard'ni tozalash
    try:
        await cb.message.edit_reply_markup(reply_markup=None)
    except Exception:
        pass  # Agar tozalashda xatolik bo'lsa, davom etamiz
    
    # Continue button qo'shamiz
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=t("finish", lang), callback_data=f"tech_finish_{req_id}")]
    ])
    
    await _preserve_mode_clear(state)
    await cb.message.answer(t("diag_cancelled", lang), reply_markup=kb)

# ====== Materiallar oqimi ======
@router.callback_query(F.data.startswith("tech_mat_select_"))
async def tech_mat_select(cb: CallbackQuery, state: FSMContext):
    st = await state.get_data(); lang = st.get("lang") or await resolve_lang(cb.from_user.id)
    try:
        payload = cb.data[len("tech_mat_select_"):]
        parts = payload.split("_")
        if len(parts) != 2:
            raise ValueError("Invalid format")
        material_id, req_id = map(int, parts)
    except Exception:
        return await cb.answer(t("format_err", lang), show_alert=True)

    user = await find_user_by_telegram_id(cb.from_user.id)
    if not user or user.get("role") != "technician":
        return await cb.answer(t("no_perm", lang), show_alert=True)

    mat = await fetch_material_by_id(material_id)
    if not mat:
        return await cb.answer(t("not_found_mat", lang), show_alert=True)

    assigned_left = await fetch_assigned_qty(user["id"], material_id)
    assigned_left = int(assigned_left or 0)

    # Source type ni aniqlash - texnikda bor yoki ombordan so'rash
    source_type = "technician_stock" if assigned_left > 0 else "warehouse"

    # Avvalgi xabardagi inline keyboard'ni tozalash
    try:
        await cb.message.edit_reply_markup(reply_markup=None)
    except Exception:
        pass  # Agar edit qila olmasa, davom etamiz

    # Application number ni olish
    mode = st.get("tech_mode", "connection")
    app_number = await get_application_number(req_id, mode)
    
    text = (
        f"{t('enter_qty', lang)}\n\n"
        f"{t('order_id', lang)} {esc(app_number)}\n"
        f"{t('chosen_prod', lang)} {esc(mat['name'])}\n"
        f"{t('price', lang)} {_fmt_price_uzs(mat['price'])} {'so\'m' if lang=='uz' else 'сум'}\n"
        f"{t('assigned_left', lang)} {assigned_left} {'dona' if lang=='uz' else 'шт'}\n\n"
        + t("enter_qty_hint", lang, max=assigned_left)
    )
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=t("btn_cancel", lang), callback_data=f"tech_qty_cancel_{req_id}")]
    ])

    await state.update_data(
        qty_ctx={
            "applications_id": req_id,
            "material_id": material_id,
            "material_name": mat["name"],
            "price": mat["price"],
            "max_qty": assigned_left,
            "lang": lang,
            "qty_message_id": None,  # Miqdor xabari ID'si
            "source_type": source_type,  # Material manbai
        }
    )

    qty_message = await cb.message.answer(text, reply_markup=kb, parse_mode="HTML")
    
    # Miqdor xabari ID'sini saqlash
    await state.update_data(
        qty_ctx={
            "applications_id": req_id,
            "material_id": material_id,
            "material_name": mat["name"],
            "price": mat["price"],
            "max_qty": assigned_left,
            "lang": lang,
            "qty_message_id": qty_message.message_id,
            "source_type": source_type,  # Material manbai
        }
    )
    
    await state.set_state(QtyStates.waiting_qty)
    await cb.answer()

@router.callback_query(F.data.startswith("tech_qty_cancel_"))
async def tech_qty_cancel(cb: CallbackQuery, state: FSMContext):
    st = await state.get_data(); lang = st.get("lang") or await resolve_lang(cb.from_user.id)
    try:
        req_id = int(cb.data.replace("tech_qty_cancel_", ""))
    except Exception:
        return await cb.answer()

    user = await find_user_by_telegram_id(cb.from_user.id)
    if not user or user.get("role") != "technician":
        return await cb.answer(t("no_perm", lang), show_alert=True)

    mode = st.get("tech_mode", "connection")
    
    # 🟢 YANGI YONDASHUV: To'g'ridan-to'g'ri DB'dan olish
    conn = await asyncpg.connect(settings.DB_URL)
    try:
        if mode == "technician":
            query = """
                SELECT * FROM technician_orders 
                WHERE id = $1
            """
        elif mode == "staff":
            query = """
                SELECT * FROM staff_orders 
                WHERE id = $1
            """
        else:
            query = """
                SELECT * FROM connection_orders 
                WHERE id = $1
            """
        
        item = await conn.fetchrow(query, req_id)
        
        if not item:
            return await cb.answer(
                "❌ Ariza topilmadi" if lang == "uz" else "❌ Заявка не найдена",
                show_alert=True
            )
        
        item = dict(item)
        
    finally:
        await conn.close()
    
    # Materiallar ro'yxatini olish
    mats = await fetch_technician_materials(user_id=user["id"])
    
    # Ariza ma'lumotlarini ko'rsatish
    text = short_view_text(item, 0, 1, lang, mode)
    
    materials_text = "\n\n📦 <b>Ombor jihozlari</b>\n"
    materials_text += "Kerakli jihozlarni tanlang yoki boshqa mahsulot kiriting:\n\n"
    
    if mats:
        for mat in mats:
            name = _short(mat.get('name', 'NO NAME'))
            price = _fmt_price_uzs(mat.get('price', 0))
            stock = mat.get('stock_quantity', '0')
            materials_text += f"📦 {name} — {price} so'm ({stock} dona)\n"
    else:
        materials_text += "• Texnikda materiallar yo'q\n"
    
    full_text = text + materials_text
    kb = materials_keyboard(mats, applications_id=req_id, lang=lang)
    
    await _safe_edit(cb.message, full_text, kb)
    await _preserve_mode_clear(state)
    await cb.answer(t("state_cleared", lang))

@router.message(StateFilter(QtyStates.waiting_qty))
async def tech_qty_entered(msg: Message, state: FSMContext):
    st = await state.get_data(); lang = st.get("lang") or await resolve_lang(msg.from_user.id)
    user = await find_user_by_telegram_id(msg.from_user.id)
    if not user or user.get("role") != "technician":
        return await msg.answer(t("no_perm", lang))

    ctx = st.get("qty_ctx") or {}
    req_id = int(ctx.get("applications_id", 0))
    material_id = int(ctx.get("material_id", 0))
    max_qty = int(ctx.get("max_qty", 0))
    qty_message_id = ctx.get("qty_message_id")
    source_type = ctx.get("source_type", "warehouse")

    try:
        qty = int((msg.text or "").strip())
        if qty <= 0:
            return await msg.answer(t("gt_zero", lang))
    except Exception:
        return await msg.answer(t("only_int", lang))

    if qty > max_qty:
        return await msg.answer(t("max_exceeded", lang, max=max_qty))

    # Miqdor xabari inline keyboard'ni tozalash
    if qty_message_id:
        try:
            await msg.bot.edit_message_reply_markup(
                chat_id=msg.chat.id,
                message_id=qty_message_id,
                reply_markup=None
            )
        except Exception:
            pass  # Agar edit qila olmasa, davom etamiz

    # Faqat tanlov saqlansin, material_requests ga yozilmasin
    # Yakunlashda barcha tanlangan materiallar yoziladi
    try:
        mode = st.get("tech_mode", "connection")
        await upsert_material_selection(
            user_id=user["id"],
            applications_id=req_id,
            material_id=material_id,
            qty=qty,
            request_type=mode,
            source_type=source_type
        )
    except ValueError as ve:
        return await msg.answer(f"❌ {ve}")
    except Exception as e:
        return await msg.answer(f"{t('x_error', lang)} {e}")

    # 🟢 YANGI YONDASHUV: To'g'ridan-to'g'ri DB'dan olish
    conn = await asyncpg.connect(settings.DB_URL)
    try:
        if mode == "technician":
            query = """
                SELECT * FROM technician_orders 
                WHERE id = $1
            """
        elif mode == "staff":
            query = """
                SELECT * FROM staff_orders 
                WHERE id = $1
            """
        else:
            query = """
                SELECT * FROM connection_orders 
                WHERE id = $1
            """
        
        item = await conn.fetchrow(query, req_id)
        
        if not item:
            return await msg.answer(
                "❌ Ariza topilmadi" if lang == "uz" else "❌ Заявка не найдена"
            )
        
        item = dict(item)
        
    finally:
        await conn.close()
    
    # Build text with order details + selected materials
    original_text = short_view_text(item, 0, 1, lang, mode)
    
    selected = await fetch_selected_materials_for_request(user["id"], req_id)
    materials_text = "\n\n📦 <b>Ishlatilayotgan mahsulotlar:</b>\n"
    
    if selected:
        for it in selected:
            qty_txt = f"{_qty_of(it)} {'dona' if lang=='uz' else 'шт'}"
            price_txt = f"{_fmt_price_uzs(it['price'])} {'so\'m' if lang=='uz' else 'сум'}"
            materials_text += f"• {esc(it['name'])} — {qty_txt} (💰 {price_txt})\n"
    else:
        materials_text += "• (tanlanmagan)\n"
    
    # Combine original text with materials
    full_text = original_text + materials_text

    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=t("add_more", lang), callback_data=f"tech_add_more_{req_id}")],
        [InlineKeyboardButton(text=t("final_view", lang), callback_data=f"tech_review_{req_id}")]
    ])
    
    # Always send new message instead of editing
    await msg.answer(full_text, reply_markup=kb, parse_mode="HTML")
    
    await _preserve_mode_clear(state)

@router.callback_query(F.data.startswith("tech_back_to_materials_"))
async def tech_back_to_materials(cb: CallbackQuery, state: FSMContext):
    st = await state.get_data(); lang = st.get("lang") or await resolve_lang(cb.from_user.id)
    try:
        req_id = int(cb.data.replace("tech_back_to_materials_", ""))
    except Exception:
        return await cb.answer()
    user = await find_user_by_telegram_id(cb.from_user.id)
    if not user or user.get("role") != "technician":
        return await cb.answer(t("no_perm", lang), show_alert=True)

    # 🟢 YANGI YONDASHUV: To'g'ridan-to'g'ri DB'dan olish
    conn = await asyncpg.connect(settings.DB_URL)
    try:
        if mode == "technician":
            query = """
                SELECT * FROM technician_orders 
                WHERE id = $1
            """
        elif mode == "staff":
            query = """
                SELECT * FROM staff_orders 
                WHERE id = $1
            """
        else:
            query = """
                SELECT * FROM connection_orders 
                WHERE id = $1
            """
        
        item = await conn.fetchrow(query, req_id)
        
        if not item:
            return await cb.answer(
                "❌ Ariza topilmadi" if lang == "uz" else "❌ Заявка не найдена",
                show_alert=True
            )
        
        item = dict(item)
        
    finally:
        await conn.close()
    
    # Restore original text with [Ombor] [Yakuniy ko'rinish] buttons
    original_text = short_view_text(item, 0, 1, lang, mode)
    
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text=t("warehouse", lang), callback_data=f"tech_add_more_{req_id}"),
            InlineKeyboardButton(text=t("review", lang), callback_data=f"tech_review_{req_id}"),
        ]
    ])
    
    await _safe_edit(cb.message, original_text, kb)
    await cb.answer()

@router.callback_query(F.data.startswith("tech_finish_"))
async def tech_finish(cb: CallbackQuery, state: FSMContext):
    st = await state.get_data(); lang = st.get("lang") or await resolve_lang(cb.from_user.id)
    try:
        req_id = int(cb.data.replace("tech_finish_", ""))
    except Exception:
        return await cb.answer()

    user = await find_user_by_telegram_id(cb.from_user.id)
    if not user or user.get("role") != "technician":
        return await cb.answer(t("no_perm", lang), show_alert=True)

    mode = st.get("tech_mode", "connection")
    selected = await fetch_selected_materials_for_request(user["id"], req_id)

    # Request type ni avval aniqlash
    if mode == "technician":
        request_type = "technician"
    elif mode == "staff":
        request_type = "staff"
    else:
        request_type = "connection"

    # Yakunlashda barcha tanlangan materiallarni material_requests ga yozish
    # Ombor yuborish allaqachon tech_confirm_warehouse da amalga oshirilgan
    if selected:
        try:
            # Faqat material_requests ga yozish
            for material in selected:
                await upsert_material_request_and_decrease_stock(
                    user_id=user["id"],
                    applications_id=req_id,
                    material_id=material['material_id'],
                    add_qty=material['qty'],
                    request_type=request_type
                )
        except Exception as e:
            logger.error(f"Error creating material requests: {e}")

    try:
        # Ariza holatini tekshirish
        conn = await asyncpg.connect(settings.DB_URL)
        try:
            if mode == "technician":
                query = "SELECT status FROM technician_orders WHERE id = $1"
            elif mode == "staff":
                query = "SELECT status FROM staff_orders WHERE id = $1"
            else:
                query = "SELECT status FROM connection_orders WHERE id = $1"
            
            result = await conn.fetchrow(query, req_id)
            if not result:
                return await cb.answer("❌ Ariza topilmadi", show_alert=True)
            
            current_status = result['status']
            
            # Agar holat in_warehouse bo'lsa, to'g'ridan-to'g'ri completed ga o'zgartirish
            if current_status == 'in_warehouse':
                if mode == "technician":
                    await conn.execute(
                        "UPDATE technician_orders SET status='completed', updated_at=NOW() WHERE id=$1",
                        req_id
                    )
                elif mode == "staff":
                    await conn.execute(
                        "UPDATE staff_orders SET status='completed', updated_at=NOW() WHERE id=$1",
                        req_id
                    )
                else:
                    await conn.execute(
                        "UPDATE connection_orders SET status='completed'::connection_order_status, updated_at=NOW() WHERE id=$1",
                        req_id
                    )
                ok = True
            else:
                # Oddiy finish_technician_work chaqirish
                if mode == "technician":
                    ok = await finish_technician_work_for_tech(applications_id=req_id, technician_id=user["id"])
                elif mode == "staff":
                    ok = await finish_technician_work_for_staff(applications_id=req_id, technician_id=user["id"])
                else:
                    ok = await finish_technician_work(applications_id=req_id, technician_id=user["id"])
        finally:
            await conn.close()
        
        if not ok:
            return await cb.answer(t("status_mismatch_finish", lang), show_alert=True)
    except Exception as e:
        return await cb.answer(f"{t('x_error', lang)} {e}", show_alert=True)

    # Application number ni olish
    app_number = await get_application_number(req_id, mode)
    lines = [t("work_finished", lang) + "\n", f"{t('order_id', lang)} {esc(app_number)}", t("used_materials", lang)]
    if selected:
        for it in selected:
            qty_txt = f"{_qty_of(it)} {'dona' if lang=='uz' else 'шт'}"
            lines.append(f"• {esc(it['name'])} — {qty_txt}")
    else:
        lines.append(T["none"][lang])

    await cb.message.answer("\n".join(lines), parse_mode="HTML")
    await cb.answer(t("finish", lang) + " ✅")

    try:
        # Avval clientga ariza haqida ma'lumot yuboramiz va rating so'ramiz
        from utils.completion_notification import send_completion_notification_to_client
        await send_completion_notification_to_client(cb.bot, req_id, request_type)
    except Exception as e:
        logger.error(f"Error sending completion notification: {e}")
        # Notification xatosi jarayonni to'xtatmaydi

@router.callback_query(F.data.startswith("tech_add_more_"))
async def tech_add_more(cb: CallbackQuery, state: FSMContext):
    st = await state.get_data(); lang = st.get("lang") or await resolve_lang(cb.from_user.id)
    req_id = int(cb.data.replace("tech_add_more_", ""))
    user = await find_user_by_telegram_id(cb.from_user.id)
    if not user or user.get("role") != "technician":
        return await cb.answer(t("no_perm", lang), show_alert=True)

    mode = st.get("tech_mode", "connection")
    
    # 🟢 YANGI YONDASHUV: To'g'ridan-to'g'ri DB'dan olish
    conn = await asyncpg.connect(settings.DB_URL)
    try:
        if mode == "technician":
            query = """
                SELECT * FROM technician_orders 
                WHERE id = $1
            """
        elif mode == "staff":
            query = """
                SELECT * FROM staff_orders 
                WHERE id = $1
            """
        else:
            query = """
                SELECT * FROM connection_orders 
                WHERE id = $1
            """
        
        item = await conn.fetchrow(query, req_id)
        
        if not item:
            return await cb.answer(
                "❌ Ariza topilmadi" if lang == "uz" else "❌ Заявка не найдена",
                show_alert=True
            )
        
        item = dict(item)
        
    finally:
        await conn.close()
    
    # Build text with order details + materials list
    original_text = short_view_text(item, 0, 1, lang, mode)
    
    # Get technician's materials only
    mats = await fetch_technician_materials(user_id=user["id"])
    
    # Add materials list to text
    materials_text = "\n\n📦 <b>Ombor jihozlari</b>\n"
    materials_text += "Kerakli jihozlarni tanlang yoki boshqa mahsulot kiriting:\n\n"
    
    if mats:
        for mat in mats:
            name = _short(mat.get('name', 'NO NAME'))
            price = _fmt_price_uzs(mat.get('price', 0))
            stock = mat.get('stock_quantity', '0')
            materials_text += f"📦 {name} — {price} so'm ({stock} dona)\n"
    else:
        materials_text += "• Texnikda materiallar yo'q\n"
    
    # Combine original text with materials
    full_text = original_text + materials_text
    
    # Edit existing message with materials keyboard
    kb = materials_keyboard(mats, applications_id=req_id, lang=lang)
    await _safe_edit(cb.message, full_text, kb)
    # Store message ID for later editing
    await state.update_data(original_message_id=cb.message.message_id)
    await cb.answer()

@router.callback_query(F.data.startswith("tech_review_"))
async def tech_review(cb: CallbackQuery, state: FSMContext):
    st = await state.get_data(); lang = st.get("lang") or await resolve_lang(cb.from_user.id)
    req_id = int(cb.data.replace("tech_review_", ""))    
    user = await find_user_by_telegram_id(cb.from_user.id)
    if not user or user.get("role") != "technician":
        return await cb.answer(t("no_perm", lang), show_alert=True)

    # Application number ni olish
    mode = st.get("tech_mode", "connection")
    app_number = await get_application_number(req_id, mode)
    
    # Material_issued ga yozish
    try:
        from database.technician.materials import create_material_issued_from_review
        await create_material_issued_from_review(user["id"], req_id, mode)
    except Exception as e:
        logger.error(f"Error creating material_issued: {e}")
    
    # 🟢 YANGI YONDASHUV: To'g'ridan-to'g'ri DB'dan olish
    conn = await asyncpg.connect(settings.DB_URL)
    try:
        if mode == "technician":
            query = """
                SELECT * FROM technician_orders 
                WHERE id = $1
            """
        elif mode == "staff":
            query = """
                SELECT * FROM staff_orders 
                WHERE id = $1
            """
        else:
            query = """
                SELECT * FROM connection_orders 
                WHERE id = $1
            """
        
        item = await conn.fetchrow(query, req_id)
        
        if not item:
            return await cb.answer(
                "❌ Ariza topilmadi" if lang == "uz" else "❌ Заявка не найдена",
                show_alert=True
            )
        
        item = dict(item)
        
    finally:
        await conn.close()
    
    # Build text with order details + materials list
    original_text = short_view_text(item, 0, 1, lang, mode)
    
    selected = await fetch_selected_materials_for_request(user["id"], req_id)
    materials_text = "\n\n📦 <b>Ishlatilgan mahsulotlar:</b>\n"
    
    if selected:
        for it in selected:
            qty_txt = f"{_qty_of(it)} {'dona' if lang=='uz' else 'шт'}"
            price_txt = f"{_fmt_price_uzs(it['price'])} {'so\'m' if lang=='uz' else 'сум'}"
            # Source indicator
            source_indicator = ""
            if it.get('source_type') == 'technician_stock':
                source_indicator = " [🧑‍🔧 O'zimda]" if lang == 'uz' else " [🧑‍🔧 У меня]"
            elif it.get('source_type') == 'warehouse':
                source_indicator = " [🏢 Ombordan]" if lang == 'uz' else " [🏢 Со склада]"
            materials_text += f"• {esc(it['name'])} — {qty_txt} (💰 {price_txt}){source_indicator}\n"
    else:
        materials_text += "• (tanlanmagan)\n"
    
    # Check if there are warehouse materials that need confirmation
    warehouse_mats = [m for m in selected if m.get('source_type') == 'warehouse']
    
    if warehouse_mats:
        # Show warehouse confirmation dialog
        warehouse_text = "\n\n🏢 <b>Ombordan so'ralgan mahsulotlar:</b>\n"
        for mat in warehouse_mats:
            qty_txt = f"{_qty_of(mat)} {'dona' if lang=='uz' else 'шт'}"
            warehouse_text += f"• {esc(mat['name'])} — {qty_txt}\n"
        warehouse_text += "\n\nOmborga yuborish tasdiqlaysizmi?"
        
        full_text = original_text + materials_text + warehouse_text
        
        kb = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="✅ Tasdiqlash", callback_data=f"tech_confirm_warehouse_{req_id}")],
            [InlineKeyboardButton(text="❌ Bekor qilish", callback_data=f"tech_back_to_materials_{req_id}")]
        ])
    else:
        # No warehouse materials, show regular buttons
        full_text = original_text + materials_text
        
        kb = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text=t("finish", lang), callback_data=f"tech_finish_{req_id}")],
            [InlineKeyboardButton(text=t("cancel_order", lang), callback_data=f"tech_cancel_order_{req_id}")],
            [InlineKeyboardButton(text=t("back", lang), callback_data=f"tech_back_to_materials_{req_id}")]
        ])
    
    await cb.message.answer(full_text, reply_markup=kb, parse_mode="HTML")
    await cb.answer()

@router.callback_query(F.data.startswith("tech_confirm_warehouse_"))
async def tech_confirm_warehouse(cb: CallbackQuery, state: FSMContext):
    st = await state.get_data()
    lang = st.get("lang") or await resolve_lang(cb.from_user.id)
    req_id = int(cb.data.replace("tech_confirm_warehouse_", ""))
    
    user = await find_user_by_telegram_id(cb.from_user.id)
    if not user or user.get("role") != "technician":
        return await cb.answer(t("no_perm", lang), show_alert=True)
    
    mode = st.get("tech_mode", "connection")
    
    # Send to warehouse
    try:
        from database.technician.materials import send_selection_to_warehouse
        success = await send_selection_to_warehouse(
            applications_id=req_id,
            technician_user_id=user["id"],
            request_type=mode
        )
        
        if success:
            # Show finish/cancel/back buttons
            # 🟢 YANGI YONDASHUV: To'g'ridan-to'g'ri DB'dan olish
            conn = await asyncpg.connect(settings.DB_URL)
            try:
                if mode == "technician":
                    query = """
                        SELECT * FROM technician_orders 
                        WHERE id = $1
                    """
                elif mode == "staff":
                    query = """
                        SELECT * FROM staff_orders 
                        WHERE id = $1
                    """
                else:
                    query = """
                        SELECT * FROM connection_orders 
                        WHERE id = $1
                    """
                
                item = await conn.fetchrow(query, req_id)
                
                if not item:
                    return await cb.answer(
                        "❌ Ariza topilmadi" if lang == "uz" else "❌ Заявка не найдена",
                        show_alert=True
                    )
                
                item = dict(item)
                
            finally:
                await conn.close()
            
            # Build text with order details + materials list
            original_text = short_view_text(item, 0, 1, lang, mode)
            
            selected = await fetch_selected_materials_for_request(user["id"], req_id)
            materials_text = "\n\n📦 <b>Ishlatilgan mahsulotlar:</b>\n"
            
            if selected:
                for it in selected:
                    qty_txt = f"{_qty_of(it)} {'dona' if lang=='uz' else 'шт'}"
                    price_txt = f"{_fmt_price_uzs(it['price'])} {'so\'m' if lang=='uz' else 'сум'}"
                    # Source indicator
                    source_indicator = ""
                    if it.get('source_type') == 'technician_stock':
                        source_indicator = " [🧑‍🔧 O'zimda]" if lang == 'uz' else " [🧑‍🔧 У меня]"
                    elif it.get('source_type') == 'warehouse':
                        source_indicator = " [🏢 Ombordan]" if lang == 'uz' else " [🏢 Со склада]"
                    materials_text += f"• {esc(it['name'])} — {qty_txt} (💰 {price_txt}){source_indicator}\n"
            else:
                materials_text += "• (tanlanmagan)\n"
            
            full_text = original_text + materials_text + "\n\n✅ Omborga yuborildi!"
            
            kb = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text=t("finish", lang), callback_data=f"tech_finish_{req_id}")],
                [InlineKeyboardButton(text=t("cancel_order", lang), callback_data=f"tech_cancel_order_{req_id}")],
                [InlineKeyboardButton(text=t("back", lang), callback_data=f"tech_back_to_materials_{req_id}")]
            ])
            
            await cb.message.answer(full_text, reply_markup=kb, parse_mode="HTML")
            try:
                await cb.answer("✅ Omborga yuborildi!")
            except Exception:
                pass  # Ignore callback timeout errors
        else:
            try:
                await cb.answer("❌ Xatolik yuz berdi", show_alert=True)
            except Exception:
                pass  # Ignore callback timeout errors
    except Exception as e:
        logger.error(f"Error sending to warehouse: {e}")
        try:
            await cb.answer("❌ Xatolik yuz berdi", show_alert=True)
        except Exception:
            pass  # Ignore callback timeout errors

@router.callback_query(F.data.startswith("tech_cancel_order_"))
async def tech_cancel_order(cb: CallbackQuery, state: FSMContext):
    st = await state.get_data()
    lang = st.get("lang") or await resolve_lang(cb.from_user.id)
    req_id = int(cb.data.replace("tech_cancel_order_", ""))
    
    user = await find_user_by_telegram_id(cb.from_user.id)
    if not user or user.get("role") != "technician":
        return await cb.answer(t("no_perm", lang), show_alert=True)
    
    mode = st.get("tech_mode", "connection")
    
    # Clear material_requests (don't touch material_and_technician)
    conn = await asyncpg.connect(settings.DB_URL)
    try:
        await conn.execute(
            "DELETE FROM material_requests WHERE user_id = $1 AND applications_id = $2",
            user["id"], req_id
        )
        
        # Update order status to cancelled
        if mode == "technician":
            await conn.execute(
                "UPDATE technician_orders SET status='cancelled', updated_at=NOW() WHERE id=$1",
                req_id
            )
        elif mode == "staff":
            await conn.execute(
                "UPDATE staff_orders SET status='cancelled', updated_at=NOW() WHERE id=$1",
                req_id
            )
        else:
            await conn.execute(
                "UPDATE connection_orders SET status='cancelled'::connection_order_status, updated_at=NOW() WHERE id=$1",
                req_id
            )
        
        await cb.answer("✅ Ariza bekor qilindi", show_alert=True)
        
        # Remove from inbox
        items = _dedup_by_id((await state.get_data()).get("tech_inbox", []))
        items = [it for it in items if it.get("id") != req_id]
        await state.update_data(tech_inbox=items)
        
        # Show next item or empty message
        if items:
            # Show first item
            item = items[0]
            text = await short_view_text_with_materials(item, 0, len(items), user["id"], lang, mode)
            kb = action_keyboard(item.get("id"), 0, len(items), item.get("status", ""), mode=mode, lang=lang)
            await _safe_edit(cb.message, text, kb)
            await state.update_data(tech_idx=0)
        else:
            await cb.message.edit_text("📭 Inbox bo'sh", reply_markup=InlineKeyboardMarkup(inline_keyboard=[]))
    finally:
        await conn.close()

@router.callback_query(F.data.startswith("tech_mat_custom_"))
async def tech_mat_custom(cb: CallbackQuery, state: FSMContext):
    await cb.answer()
    st = await state.get_data(); lang = st.get("lang") or await resolve_lang(cb.from_user.id)
    try:
        req_id = int(cb.data.replace("tech_mat_custom_", ""))
    except Exception:
        return
    
    user = await find_user_by_telegram_id(cb.from_user.id)
    if not user or user.get("role") != "technician":
        return await cb.answer(t("no_perm", lang), show_alert=True)
    
    # Get all materials (25 total) and filter out technician's materials (7 items)
    # Result: 18 materials from warehouse only
    all_mats = await fetch_all_materials(limit=200, offset=0)
    tech_mats = await fetch_technician_materials(user_id=user["id"])
    
    # Get technician's material IDs
    tech_material_ids = {mat['material_id'] for mat in tech_mats}
    
    # Filter out materials that technician already has
    warehouse_mats = [mat for mat in all_mats if mat['material_id'] not in tech_material_ids]
    
    if not warehouse_mats:
        return await cb.message.answer(
            ("📦 Ombordan qo'shimcha materiallar yo'q" if lang == "uz" else "📦 Нет дополнительных материалов на складе"),
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text=T["back"][lang], callback_data=f"tech_back_to_materials_{req_id}")]
            ])
        )

    # Application number ni olish
    mode = st.get("tech_mode", "connection")
    app_number = await get_application_number(req_id, mode)
    
    header_text = ("📦 <b>Ombordan qo'shimcha materiallar</b>\n🆔 <b>Ariza ID:</b> {id}\nKerakli materialni tanlang:" if lang == "uz" else "📦 <b>Дополнительные материалы со склада</b>\n🆔 <b>ID заявки:</b> {id}\nВыберите нужный материал:")
    
    # Edit existing message instead of sending new one
    await _safe_edit(
        cb.message, 
        header_text.format(id=app_number), 
        unassigned_materials_keyboard(warehouse_mats, applications_id=req_id, lang=lang)
    )

@router.callback_query(F.data.startswith("tech_unassigned_select_"))
async def tech_unassigned_select(cb: CallbackQuery, state: FSMContext):
    """Texnikka biriktirilmagan materialni tanlash"""
    await cb.answer()
    st = await state.get_data(); lang = st.get("lang") or await resolve_lang(cb.from_user.id)
    try:
        payload = cb.data[len("tech_unassigned_select_"):]
        material_id, req_id = map(int, payload.split("_", 1))
    except Exception:
        return

    mat = await fetch_material_by_id(material_id)
    if not mat:
        return await cb.answer(t("not_found_mat", lang), show_alert=True)

    mode = st.get("tech_mode", "connection")
    app_number = await get_application_number(req_id, mode)
    
    text = (
        f"📦 <b>{t('product', lang)}:</b> {esc(mat['name'])}\n"
        f"💰 <b>{t('price_line', lang)}:</b> {_fmt_price_uzs(mat.get('price',0))} {'so\'m' if lang=='uz' else 'сум'}\n"
        f"🆔 <b>{t('order', lang)}:</b> {esc(app_number)}\n\n"
        f"{'Miqdorini kiriting:' if lang=='uz' else 'Введите количество:'}"
    )
    
    await state.update_data(
        qty_ctx={
            "applications_id": req_id,
            "material_id": material_id,
            "material_name": mat["name"],
            "price": mat["price"],
            "max_qty": 999,  
            "lang": lang,
            "source_type": "warehouse",
            "qty_message_id": cb.message.message_id  
        }
    )
    
    # Show quantity input prompt with cancel button
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=t("btn_cancel", lang), callback_data=f"tech_qty_cancel_{req_id}")]
    ])
    
    await cb.message.answer(text, reply_markup=kb, parse_mode="HTML")
    await state.set_state(QtyStates.waiting_qty)

@router.callback_query(F.data.startswith("tech_custom_select_"))
async def tech_custom_select(cb: CallbackQuery, state: FSMContext):
    await cb.answer()
    st = await state.get_data(); lang = st.get("lang") or await resolve_lang(cb.from_user.id)
    try:
        payload = cb.data[len("tech_custom_select_"):]
        material_id, req_id = map(int, payload.split("_", 1))
    except Exception:
        return

    mat = await fetch_material_by_id(material_id)
    if not mat:
        return await cb.answer(t("not_found_mat", lang), show_alert=True)

    # Material ma'lumotlarini ko'rsatish va tasdiqlash so'rash
    mode = st.get("tech_mode", "connection")
    app_number = await get_application_number(req_id, mode)
    
    text = (
        f"📦 <b>{t('product', lang)}:</b> {esc(mat['name'])}\n"
        f"💰 <b>{t('price_line', lang)}:</b> {_fmt_price_uzs(mat.get('price',0))} {'so\'m' if lang=='uz' else 'сум'}\n"
        f"🆔 <b>{t('order', lang)}:</b> {esc(app_number)}\n\n"
        f"{'Bu materialni tanlamoqchimisiz?' if lang=='uz' else 'Хотите выбрать этот материал?'}"
    )
    
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(
                text="✅ Ha" if lang=='uz' else "✅ Да", 
                callback_data=f"tech_confirm_custom_{material_id}_{req_id}"
            ),
            InlineKeyboardButton(
                text="❌ Yo'q" if lang=='uz' else "❌ Нет", 
                callback_data=f"tech_back_to_materials_{req_id}"
            )
        ]
    ])

    await cb.message.answer(text, reply_markup=kb, parse_mode="HTML")

@router.callback_query(F.data.startswith("tech_confirm_unassigned_"))
async def tech_confirm_unassigned(cb: CallbackQuery, state: FSMContext):
    """Texnikka biriktirilmagan materialni tasdiqlagandan so'ng miqdor kiritish"""
    await cb.answer()
    st = await state.get_data(); lang = st.get("lang") or await resolve_lang(cb.from_user.id)
    
    try:
        payload = cb.data[len("tech_confirm_unassigned_"):]
        material_id, req_id = map(int, payload.split("_", 1))
    except Exception:
        return

    mat = await fetch_material_by_id(material_id)
    if not mat:
        return await cb.answer(t("not_found_mat", lang), show_alert=True)

    await state.update_data(unassigned_ctx={
        "applications_id": req_id,
        "material_id": material_id,
        "material_name": mat["name"],
        "price": mat.get("price", 0),
        "lang": lang,
    })

    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=t("btn_cancel", lang), callback_data=f"tech_back_to_materials_{req_id}")]
    ])

    # Application number ni olish
    mode = st.get("tech_mode", "connection")
    app_number = await get_application_number(req_id, mode)
    
    await cb.message.answer(
        f"{t('qty_title', lang)}\n\n"
        f"{t('order', lang)} {esc(app_number)}\n"
        f"{t('product', lang)} {esc(mat['name'])}\n"
        f"{t('price_line', lang)} {_fmt_price_uzs(mat.get('price',0))} {'so\'m' if lang=='uz' else 'сум'}\n\n"
        f"{'Miqdorni kiriting (faqat raqam):' if lang=='uz' else 'Введите количество (только число):'}\n\n"
        f"{'⚠️ Bu material texnikka biriktirilmagan. Omborchi tasdiqlagandan so\'ng texnikka biriktiriladi.' if lang=='uz' else '⚠️ Этот материал не привязан к технику. После подтверждения склада будет привязан к технику.'}",
        reply_markup=kb,
        parse_mode="HTML"
    )
    await state.set_state(CustomQtyStates.waiting_qty)

@router.callback_query(F.data.startswith("tech_confirm_custom_"))
async def tech_confirm_custom(cb: CallbackQuery, state: FSMContext):
    """Materialni tasdiqlagandan so'ng miqdor kiritish"""
    await cb.answer()
    st = await state.get_data(); lang = st.get("lang") or await resolve_lang(cb.from_user.id)
    
    try:
        payload = cb.data[len("tech_confirm_custom_"):]
        material_id, req_id = map(int, payload.split("_", 1))
    except Exception:
        return

    mat = await fetch_material_by_id(material_id)
    if not mat:
        return await cb.answer(t("not_found_mat", lang), show_alert=True)

    await state.update_data(custom_ctx={
        "applications_id": req_id,
        "material_id": material_id,
        "material_name": mat["name"],
        "price": mat.get("price", 0),
        "lang": lang,
    })

    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=t("btn_cancel", lang), callback_data=f"tech_back_to_materials_{req_id}")]
    ])

    # Application number ni olish
    mode = st.get("tech_mode", "connection")
    app_number = await get_application_number(req_id, mode)
    
    await cb.message.answer(
        f"{t('qty_title', lang)}\n\n"
        f"{t('order', lang)} {esc(app_number)}\n"
        f"{t('product', lang)} {esc(mat['name'])}\n"
        f"{t('price_line', lang)} {_fmt_price_uzs(mat.get('price',0))} {'so\'m' if lang=='uz' else 'сум'}\n\n"
        f"{t('only_int', lang)}",
        reply_markup=kb,
        parse_mode="HTML"
    )
    await state.set_state(CustomQtyStates.waiting_qty)

@router.message(StateFilter(CustomQtyStates.waiting_qty))
async def custom_qty_entered(msg: Message, state: FSMContext):
    st = await state.get_data(); lang = st.get("lang") or await resolve_lang(msg.from_user.id)
    user = await find_user_by_telegram_id(msg.from_user.id)
    if not user or user.get("role") != "technician":
        return await msg.answer(t("no_perm", lang))

    # Texnikka biriktirilmagan materiallar uchun alohida kontekst
    unassigned_ctx = st.get("unassigned_ctx")
    if unassigned_ctx:
        req_id = int(unassigned_ctx.get("applications_id", 0))
        material_id = int(unassigned_ctx.get("material_id", 0))
        material_name = unassigned_ctx.get("material_name", "")
        
        try:
            qty = int((msg.text or "").strip())
            if qty <= 0:
                return await msg.answer(t("gt_zero", lang))
        except Exception:
            return await msg.answer(t("only_int", lang))

        # Texnikka biriktirilmagan material uchun faqat tanlov saqlash
        try:
            mode = st.get("tech_mode", "connection")
            await upsert_material_selection(
                user_id=user["id"],
                applications_id=req_id,
                material_id=material_id,
                qty=qty,
                request_type=mode,
                source_type="warehouse"  # Unassigned materials are from warehouse
            )
        except Exception as e:
            return await msg.answer(f"{t('x_error', lang)} {e}")

        # Application number ni olish
        mode = st.get("tech_mode", "connection")
        app_number = await get_application_number(req_id, mode)
        
        # Xabar yuborish
        await msg.answer(
            f"✅ <b>Material omborga so'rov yuborildi</b>\n\n"
            f"📦 <b>Material:</b> {esc(material_name)}\n"
            f"📊 <b>Miqdor:</b> {qty} {'dona' if lang=='uz' else 'шт'}\n"
            f"🆔 <b>Ariza ID:</b> {esc(app_number)}\n\n"
            f"{'Omborchi tasdiqlagandan so\'ng material texnikka biriktiriladi' if lang=='uz' else 'После подтверждения склада материал будет привязан к технику'}\n\n"
            f"{'Yana material qo\'shish uchun \"Ombor\" tugmasini bosing' if lang=='uz' else 'Для добавления ещё материалов нажмите кнопку \"Склад\"'}",
            parse_mode="HTML"
        )
        
        await _preserve_mode_clear(state)
        return

    # Oddiy custom materiallar uchun eski mantiq
    ctx  = st.get("custom_ctx") or {}
    req_id      = int(ctx.get("applications_id", 0))
    material_id = int(ctx.get("material_id", 0))
    if not (req_id and material_id):
        await _preserve_mode_clear(state)
        return await msg.answer(t("ctx_lost", lang))

    try:
        qty = int((msg.text or "").strip())
        if qty <= 0:
            return await msg.answer(t("gt_zero", lang))
    except Exception:
        return await msg.answer(t("only_int", lang))

    mode = st.get("tech_mode", "connection")
    request_type = "technician" if mode == "technician" else ("staff" if mode == "staff" else "connection")

    # Faqat tanlov saqlansin, omborga yuborilmasin
    # Yakunlashda barcha materiallar omborga yuboriladi
    try:
        mode = st.get("tech_mode", "connection")
        await upsert_material_selection(
            user_id=user["id"],
            applications_id=req_id,
            material_id=material_id,
            qty=qty,
            request_type=mode,
            source_type="warehouse"  # Custom materials are from warehouse
        )
    except Exception as e:
        return await msg.answer(f"{t('x_error', lang)} {e}")

    # Application number ni olish
    mode = st.get("tech_mode", "connection")
    app_number = await get_application_number(req_id, mode)
    
    # Tanlangan materiallarni ko'rsatish
    selected = await fetch_selected_materials_for_request(user["id"], req_id)
    lines = [t("saved_selection", lang) + "\n", f"{t('order_id', lang)} {esc(app_number)}", t("selected_products", lang)]
    for it in selected:
        qty_txt = f"{_qty_of(it)} {'dona' if lang=='uz' else 'шт'}"
        price_txt = f"{_fmt_price_uzs(it['price'])} {'so\'m' if lang=='uz' else 'сум'}"
        lines.append(f"• {esc(it['name'])} — {qty_txt} (💰 {price_txt})")

    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=t("add_more", lang), callback_data=f"tech_add_more_{req_id}")],
        [InlineKeyboardButton(text=t("final_view", lang), callback_data=f"tech_review_{req_id}")]
    ])
    
    await _preserve_mode_clear(state)
    await msg.answer("\n".join(lines), reply_markup=kb, parse_mode="HTML")
